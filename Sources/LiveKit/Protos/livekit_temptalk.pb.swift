// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: livekit_temptalk.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 LiveKit, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Livekit_TTCaller: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var did: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Livekit_TTExceptionRecipient: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var registrationID: Int32 = 0

  public var identityKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Livekit_TTBaseResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ver: UInt32 = 0

  public var status: UInt32 = 0

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Livekit_TTCallResponseBody: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var needsSync: Bool {
    get {return _storage._needsSync}
    set {_uniqueStorage()._needsSync = newValue}
  }

  public var invalidUids: [String] {
    get {return _storage._invalidUids}
    set {_uniqueStorage()._invalidUids = newValue}
  }

  public var stale: [Livekit_TTExceptionRecipient] {
    get {return _storage._stale}
    set {_uniqueStorage()._stale = newValue}
  }

  public var missing: [Livekit_TTExceptionRecipient] {
    get {return _storage._missing}
    set {_uniqueStorage()._missing = newValue}
  }

  public var extra: [Livekit_TTExceptionRecipient] {
    get {return _storage._extra}
    set {_uniqueStorage()._extra = newValue}
  }

  public var encMeta: Dictionary<String,String> {
    get {return _storage._encMeta}
    set {_uniqueStorage()._encMeta = newValue}
  }

  public var roomID: String {
    get {return _storage._roomID}
    set {_uniqueStorage()._roomID = newValue}
  }

  /// in milliseconds
  public var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  public var serviceURL: String {
    get {return _storage._serviceURL}
    set {_uniqueStorage()._serviceURL = newValue}
  }

  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  public var caller: Livekit_TTCaller {
    get {return _storage._caller ?? Livekit_TTCaller()}
    set {_uniqueStorage()._caller = newValue}
  }
  /// Returns true if `caller` has been explicitly set.
  public var hasCaller: Bool {return _storage._caller != nil}
  /// Clears the value of `caller`. Subsequent reads from it will return its default value.
  public mutating func clearCaller() {_uniqueStorage()._caller = nil}

  public var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  public var emk: String {
    get {return _storage._emk}
    set {_uniqueStorage()._emk = newValue}
  }

  public var publicKey: String {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  public var serviceUrls: [String] {
    get {return _storage._serviceUrls}
    set {_uniqueStorage()._serviceUrls = newValue}
  }

  /// in milliseconds
  public var systemShowTimestamp: UInt64 {
    get {return _storage._systemShowTimestamp}
    set {_uniqueStorage()._systemShowTimestamp = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Livekit_TTCallResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var base: Livekit_TTBaseResponse {
    get {return _base ?? Livekit_TTBaseResponse()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  public var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  public mutating func clearBase() {self._base = nil}

  public var body: Livekit_TTCallResponseBody {
    get {return _body ?? Livekit_TTCallResponseBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _base: Livekit_TTBaseResponse? = nil
  fileprivate var _body: Livekit_TTCallResponseBody? = nil
}

public struct Livekit_TTCipherMessages: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String = String()

  public var uid: String = String()

  public var registrationID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Livekit_TTEncInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var emk: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Livekit_TTNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Int32 = 0

  public var args: Livekit_TTNotification.TTArgs {
    get {return _args ?? Livekit_TTNotification.TTArgs()}
    set {_args = newValue}
  }
  /// Returns true if `args` has been explicitly set.
  public var hasArgs: Bool {return self._args != nil}
  /// Clears the value of `args`. Subsequent reads from it will return its default value.
  public mutating func clearArgs() {self._args = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct TTArgs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var collapseID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _args: Livekit_TTNotification.TTArgs? = nil
}

public struct Livekit_TTStartCall: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [must] 1on1, group, instant
  public var type: String = String()

  public var version: Int32 = 0

  public var roomID: String = String()

  /// conversation id
  public var conversationID: String = String()

  public var publicKey: String = String()

  public var encInfos: [Livekit_TTEncInfo] = []

  public var encMeta: Dictionary<String,String> = [:]

  /// in milliseconds
  public var timestamp: Int64 = 0

  public var notification: Livekit_TTNotification {
    get {return _notification ?? Livekit_TTNotification()}
    set {_notification = newValue}
  }
  /// Returns true if `notification` has been explicitly set.
  public var hasNotification: Bool {return self._notification != nil}
  /// Clears the value of `notification`. Subsequent reads from it will return its default value.
  public mutating func clearNotification() {self._notification = nil}

  public var cipherMessages: [Livekit_TTCipherMessages] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _notification: Livekit_TTNotification? = nil
}

public struct Livekit_TTCallRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// client token: for verify
  public var token: String = String()

  public var startCall: Livekit_TTStartCall {
    get {return _startCall ?? Livekit_TTStartCall()}
    set {_startCall = newValue}
  }
  /// Returns true if `startCall` has been explicitly set.
  public var hasStartCall: Bool {return self._startCall != nil}
  /// Clears the value of `startCall`. Subsequent reads from it will return its default value.
  public mutating func clearStartCall() {self._startCall = nil}

  public var userAgent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startCall: Livekit_TTStartCall? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "livekit"

extension Livekit_TTCaller: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTCaller"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "did"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.did) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if self.did != 0 {
      try visitor.visitSingularInt32Field(value: self.did, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTCaller, rhs: Livekit_TTCaller) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.did != rhs.did {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTExceptionRecipient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTExceptionRecipient"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "registrationId"),
    3: .same(proto: "identityKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.registrationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identityKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if self.registrationID != 0 {
      try visitor.visitSingularInt32Field(value: self.registrationID, fieldNumber: 2)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularStringField(value: self.identityKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTExceptionRecipient, rhs: Livekit_TTExceptionRecipient) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.registrationID != rhs.registrationID {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTBaseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTBaseResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != 0 {
      try visitor.visitSingularUInt32Field(value: self.status, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTBaseResponse, rhs: Livekit_TTBaseResponse) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTCallResponseBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTCallResponseBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "needsSync"),
    2: .same(proto: "invalidUids"),
    3: .same(proto: "stale"),
    4: .same(proto: "missing"),
    5: .same(proto: "extra"),
    6: .same(proto: "encMeta"),
    7: .same(proto: "roomId"),
    8: .same(proto: "createdAt"),
    9: .same(proto: "serviceUrl"),
    10: .same(proto: "token"),
    11: .same(proto: "caller"),
    12: .same(proto: "version"),
    13: .same(proto: "emk"),
    14: .same(proto: "publicKey"),
    15: .same(proto: "serviceUrls"),
    16: .same(proto: "systemShowTimestamp"),
  ]

  fileprivate class _StorageClass {
    var _needsSync: Bool = false
    var _invalidUids: [String] = []
    var _stale: [Livekit_TTExceptionRecipient] = []
    var _missing: [Livekit_TTExceptionRecipient] = []
    var _extra: [Livekit_TTExceptionRecipient] = []
    var _encMeta: Dictionary<String,String> = [:]
    var _roomID: String = String()
    var _createdAt: Int64 = 0
    var _serviceURL: String = String()
    var _token: String = String()
    var _caller: Livekit_TTCaller? = nil
    var _version: Int32 = 0
    var _emk: String = String()
    var _publicKey: String = String()
    var _serviceUrls: [String] = []
    var _systemShowTimestamp: UInt64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _needsSync = source._needsSync
      _invalidUids = source._invalidUids
      _stale = source._stale
      _missing = source._missing
      _extra = source._extra
      _encMeta = source._encMeta
      _roomID = source._roomID
      _createdAt = source._createdAt
      _serviceURL = source._serviceURL
      _token = source._token
      _caller = source._caller
      _version = source._version
      _emk = source._emk
      _publicKey = source._publicKey
      _serviceUrls = source._serviceUrls
      _systemShowTimestamp = source._systemShowTimestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._needsSync) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._invalidUids) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._stale) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._missing) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._extra) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._encMeta) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._roomID) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._serviceURL) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._caller) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._version) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._emk) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._publicKey) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._serviceUrls) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._systemShowTimestamp) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._needsSync != false {
        try visitor.visitSingularBoolField(value: _storage._needsSync, fieldNumber: 1)
      }
      if !_storage._invalidUids.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._invalidUids, fieldNumber: 2)
      }
      if !_storage._stale.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stale, fieldNumber: 3)
      }
      if !_storage._missing.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._missing, fieldNumber: 4)
      }
      if !_storage._extra.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._extra, fieldNumber: 5)
      }
      if !_storage._encMeta.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._encMeta, fieldNumber: 6)
      }
      if !_storage._roomID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._roomID, fieldNumber: 7)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 8)
      }
      if !_storage._serviceURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serviceURL, fieldNumber: 9)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 10)
      }
      try { if let v = _storage._caller {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._version != 0 {
        try visitor.visitSingularInt32Field(value: _storage._version, fieldNumber: 12)
      }
      if !_storage._emk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._emk, fieldNumber: 13)
      }
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._publicKey, fieldNumber: 14)
      }
      if !_storage._serviceUrls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._serviceUrls, fieldNumber: 15)
      }
      if _storage._systemShowTimestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._systemShowTimestamp, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTCallResponseBody, rhs: Livekit_TTCallResponseBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._needsSync != rhs_storage._needsSync {return false}
        if _storage._invalidUids != rhs_storage._invalidUids {return false}
        if _storage._stale != rhs_storage._stale {return false}
        if _storage._missing != rhs_storage._missing {return false}
        if _storage._extra != rhs_storage._extra {return false}
        if _storage._encMeta != rhs_storage._encMeta {return false}
        if _storage._roomID != rhs_storage._roomID {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._serviceURL != rhs_storage._serviceURL {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._caller != rhs_storage._caller {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._emk != rhs_storage._emk {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._serviceUrls != rhs_storage._serviceUrls {return false}
        if _storage._systemShowTimestamp != rhs_storage._systemShowTimestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTCallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTCallResponse, rhs: Livekit_TTCallResponse) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTCipherMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTCipherMessages"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "uid"),
    3: .same(proto: "registrationId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.registrationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 2)
    }
    if self.registrationID != 0 {
      try visitor.visitSingularInt32Field(value: self.registrationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTCipherMessages, rhs: Livekit_TTCipherMessages) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.registrationID != rhs.registrationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTEncInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTEncInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "emk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.emk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.emk.isEmpty {
      try visitor.visitSingularStringField(value: self.emk, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTEncInfo, rhs: Livekit_TTEncInfo) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.emk != rhs.emk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._args) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._args {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTNotification, rhs: Livekit_TTNotification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._args != rhs._args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTNotification.TTArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Livekit_TTNotification.protoMessageName + ".TTArgs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collapseId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collapseID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collapseID.isEmpty {
      try visitor.visitSingularStringField(value: self.collapseID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTNotification.TTArgs, rhs: Livekit_TTNotification.TTArgs) -> Bool {
    if lhs.collapseID != rhs.collapseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTStartCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTStartCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "version"),
    3: .same(proto: "roomId"),
    4: .same(proto: "conversationId"),
    5: .same(proto: "publicKey"),
    6: .same(proto: "encInfos"),
    7: .same(proto: "encMeta"),
    8: .same(proto: "timestamp"),
    9: .same(proto: "notification"),
    10: .same(proto: "cipherMessages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.encInfos) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.encMeta) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._notification) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.cipherMessages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 3)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 4)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 5)
    }
    if !self.encInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.encInfos, fieldNumber: 6)
    }
    if !self.encMeta.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.encMeta, fieldNumber: 7)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 8)
    }
    try { if let v = self._notification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.cipherMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cipherMessages, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTStartCall, rhs: Livekit_TTStartCall) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.version != rhs.version {return false}
    if lhs.roomID != rhs.roomID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.encInfos != rhs.encInfos {return false}
    if lhs.encMeta != rhs.encMeta {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._notification != rhs._notification {return false}
    if lhs.cipherMessages != rhs.cipherMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TTCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTCallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "startCall"),
    3: .same(proto: "userAgent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startCall) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try { if let v = self._startCall {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Livekit_TTCallRequest, rhs: Livekit_TTCallRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._startCall != rhs._startCall {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
